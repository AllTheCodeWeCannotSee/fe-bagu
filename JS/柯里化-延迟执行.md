![[Pasted image 20240915105412.png]]



```javascript
function add(...args) {
  // 内部函数sum用于继续接收新的参数
  const sum = (...newArgs) => add(...args, ...newArgs);
  
  // 重写sum函数的toString方法，当sum被转换为字符串时，返回参数的总和
  sum.toString = () => args.reduce((acc, cur) => acc + cur, 0);
  
  return sum;
}
```

### 详细解释：

**1. 初始函数 `add(...args)`**

- 使用**剩余参数语法**`...args`，可以接受任意数量的参数，参数被收集为一个数组`args`。

**2. 内部函数 `sum`**

- `sum`是一个箭头函数，也使用剩余参数`...newArgs`，用于接收新的参数。
- 当`sum`被调用时，它会递归调用`add`函数，将之前的参数`args`与新的参数`newArgs`合并：`add(...args, ...newArgs)`。

**3. 重写 `toString` 方法**

- `sum.toString`被重写为一个函数，当`sum`需要转换为字符串时，会调用这个方法。
- `toString`方法使用`args.reduce((acc, cur) => acc + cur, 0)`计算参数数组`args`的总和。

**4. 返回 `sum` 函数**

- `add`函数返回`sum`函数，使得可以进行链式调用。

### 执行流程示例：

**示例：`console.log(add(1)(2)(3));`**

- **第一次调用：** `add(1)`
  - `args = [1]`
  - 返回`sum`函数。
  
- **第二次调用：** `(2)`
  - 调用`sum(2)`，即`add(1, 2)`
  - `args = [1, 2]`
  - 返回新的`sum`函数。

- **第三次调用：** `(3)`
  - 调用`sum(3)`，即`add(1, 2, 3)`
  - `args = [1, 2, 3]`
  - 返回新的`sum`函数。

- **输出阶段：**
  - `console.log`试图打印`sum`函数。
  - JavaScript会尝试将函数转换为字符串，调用`sum.toString()`方法。
  - `toString`方法计算并返回`args`的总和：`1 + 2 + 3 = 6`。
  - 输出结果：`6`。

**其他示例：**

- `console.log(add(1, 2, 3)(4));`
  - 参数累积为`[1, 2, 3, 4]`，总和为`10`。

- `console.log(add(1)(2)(3)(4)(5));`
  - 参数累积为`[1, 2, 3, 4, 5]`，总和为`15`。

### 关于递归：

- **递归调用 `add` 函数：**
  - 每次调用`sum`时，实际上是递归调用`add`，将新的参数追加到已有的参数列表中。
  - 递归在这里用于累积参数，而不是直接计算结果。

- **递归的终止：**
  - 递归没有显式的终止条件，但在尝试输出结果时（如`console.log`），会触发`toString`方法，计算并返回总和。

### 关键点解析：

- **函数柯里化：**
  - 这种连续调用函数的方式称为柯里化（Currying），将多参数函数转换为一系列单参数函数的调用。

- **重写 `toString` 方法：**
  - 在JavaScript中，函数也是对象，可以有自己的属性和方法。
  - 重写`toString`方法，使得函数在需要转换为字符串时，返回我们想要的值。

- **隐式类型转换：**
  - `console.log`在打印函数时，会调用函数的`toString`方法，这是因为函数需要被转换为字符串才能输出。

### 总结：

这段代码巧妙地结合了**递归**、**函数柯里化**和**JavaScript的类型转换机制**，实现了一个可连续调用并累加参数的求和函数。每次调用都会返回一个新的函数，直到需要输出结果时，通过重写的`toString`方法计算并返回参数的总和。