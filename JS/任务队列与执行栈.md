![[Pasted image 20240911092514.png]]

- [[执行上下文]]


- **执行栈**：==同步代码==会被立即执行并压入执行栈中，执行完成后出栈。
- **任务队列**：==异步代码==如 `setTimeout` 会被推入任务队列中，等待指定的时间后，执行栈清空，异步任务才会被放入栈中执行。

### 代码解析
```javascript
for (var i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(i++);
    }, 4000);
}

console.log(i);
```

#### 1. **for 循环执行**
- `for` 循环中的变量 `i` 是用 `var` 声明的，它的作用域是**全局作用域**。
- 当 `for` 循环执行完毕时，`i` 的值变成了 `5`，因为 `i` 从 `0` 递增到 `5`。
- 此时，`console.log(i)` 会立即输出 `5`，因为循环已经结束，`i` 的值已经变为 `5`。

#### 2. **`setTimeout` 的执行**
- `setTimeout` 是一个**异步函数**，它会在指定的时间（这里是 4000 毫秒）后执行其回调函数。
- 回调函数 `function() { console.log(i++); }` 在任务队列中等待，直到 `for` 循环和所有同步代码执行完毕。
- 由于 `setTimeout` 的回调函数在任务队列中等待，直到 4000 毫秒后才开始执行，这时 `for` 循环早已结束，因此 `i` 的值在所有 `setTimeout` 回调执行时都是 `5`。

#### 3. **执行顺序**
- 当 `for` 循环结束时，`i` 已经等于 `5`。
- 4000 毫秒后，任务队列中的 `setTimeout` 回调函数开始执行，由于 `i` 是全局变量，每次执行 `console.log(i++)` 时，`i` 的值都是从 `5` 开始，依次递增。

因此，最终输出的结果是：
```
5  // 立即输出，来自 `console.log(i)`
5  // 4000 毫秒后，5 来自第一次 `setTimeout`
6  // 第二次 `setTimeout`
7  // 第三次 `setTimeout`
8  // 第四次 `setTimeout`
9  // 第五次 `setTimeout`
```



在这个例子中，`for` 循环是同步代码，先执行；而 `setTimeout` 是异步任务，它的回调被放入任务队列中，等到所有同步代码执行完毕，并且 4000 毫秒过去后，任务队列中的回调才会被执行。
