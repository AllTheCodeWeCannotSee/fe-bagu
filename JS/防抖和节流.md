总结

- **防抖**适合处理用户输入、调整窗口大小等，需要在一段时间内确定用户停止操作后才执行的场景。
- **节流**适合处理滚动事件、按钮点击等，需要控制函数执行频率，防止因频繁调用导致性能问题的场景。

两者的核心区别在于：
- 防抖是“等用户停止操作后再执行一次”；
- 节流是“每隔一段时间执行一次，不管用户操作多频繁”。



### 防抖（Debounce）

防抖是一种在事件触发后，只有在特定时间内没有再次触发事件时，才会执行函数的技术。它的作用是将多次频繁的调用合并为一次。

#### 原理：
- 在事件连续触发时，防抖函数会不断重置计时器，只有在最后一次事件触发后的设定时间内没有再次触发事件，才会执行函数。

#### 使用场景：
- 输入框搜索建议：用户在输入过程中，不希望每次按键都发送请求，而是在用户停止输入一段时间后再发送请求。
- 浏览器窗口调整：在用户停止调整浏览器窗口大小后再进行计算或重新渲染页面。

#### 实现示例：

防抖通常用于处理用户输入等场景，例如在用户停止输入后再发送请求。可以通过自定义 Hook 实现防抖功能。

```javascript
import React, { useState, useEffect } from 'react';

// 自定义防抖 Hook
function useDebounce(value, delay) {
    const [debouncedValue, setDebouncedValue] = useState(value);

    useEffect(() => {
        const handler = setTimeout(() => {
            setDebouncedValue(value);
        }, delay);

        // 清除上一次的定时器
        return () => {
            clearTimeout(handler);
        };
    }, [value, delay]);

    return debouncedValue;
}

function DebouncedInput() {
    const [inputValue, setInputValue] = useState('');
    const debouncedValue = useDebounce(inputValue, 500); // 500 毫秒的防抖

    useEffect(() => {
        if (debouncedValue) {
            console.log('Debounced value:', debouncedValue);
            // 在此发送请求或者执行其他操作
        }
    }, [debouncedValue]);

    return (
        <input
            type="text"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            placeholder="Type something..."
        />
    );
}

export default DebouncedInput;
```

在这个示例中，`useDebounce` 是一个自定义的 Hook，用于对输入值进行防抖处理。输入框在用户停止输入 500 毫秒后才会更新 `debouncedValue`，并触发副作用（例如发送请求）。


### 节流（Throttle）

节流是一种在连续事件触发时，保证在一定时间间隔内只执行一次函数的技术。它的作用是限制函数的执行频率。

#### 原理：
- 当事件不断触发时，节流函数会按照设定的时间间隔执行一次，不管事件触发的频率有多高。

#### 使用场景：
- 页面滚动：在用户滚动页面时，可以在固定的时间间隔内更新一些状态，而不是每次滚动事件触发时都执行。
- 按钮点击：防止用户连续快速点击按钮，导致多次执行点击事件处理函数。

#### 实现示例：

节流通常用于处理滚动、窗口调整大小等高频率触发的事件。可以通过自定义 Hook 实现节流功能。

```javascript
import React, { useState, useEffect } from 'react';

// 自定义节流 Hook
function useThrottle(value, limit) {
    const [throttledValue, setThrottledValue] = useState(value);

    useEffect(() => {
        const lastRan = Date.now();

        const handler = setTimeout(() => {
            if (Date.now() - lastRan >= limit) {
                setThrottledValue(value);
            }
        }, limit - (Date.now() - lastRan));

        // 清除上一次的定时器
        return () => {
            clearTimeout(handler);
        };
    }, [value, limit]);

    return throttledValue;
}

function ThrottledScroll() {
    const [scrollPosition, setScrollPosition] = useState(0);
    const throttledScroll = useThrottle(scrollPosition, 200); // 200 毫秒的节流

    useEffect(() => {
        const handleScroll = () => {
            setScrollPosition(window.scrollY);
        };

        window.addEventListener('scroll', handleScroll);

        return () => {
            window.removeEventListener('scroll', handleScroll);
        };
    }, []);

    useEffect(() => {
        console.log('Throttled scroll position:', throttledScroll);
        // 在此执行节流后的滚动处理逻辑
    }, [throttledScroll]);

    return <div style={{ height: '150vh' }}>Scroll down to see the effect</div>;
}

export default ThrottledScroll;
```

在这个示例中，`useThrottle` 是一个自定义的 Hook，用于对滚动位置进行节流处理。滚动事件每隔 200 毫秒才会更新 `throttledScroll`，并触发副作用。

这两个示例展示了如何在 React 中实现防抖和节流，以优化应用程序的性能和用户体验。


