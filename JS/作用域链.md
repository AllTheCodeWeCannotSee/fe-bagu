![[Untitled diagram-2024-09-15-022953.png]]


---

## 代码概览

```javascript
function outer() {
  var b = 2; // outer 作用域

  return function inner() {
    console.log(b); // 通过闭包访问 outer 中的 b
  };
}

var innerFunc = outer(); // outer 执行完毕
innerFunc(); // 输出 2
```

---

## 1. 全局执行上下文的创建

当 JavaScript 引擎开始执行这段代码时，首先会创建**全局执行上下文**，并将其压入**执行栈**（Execution Stack）。全局执行上下文包含：

- **变量环境（Variable Environment）**：存储全局变量和函数声明。
- **词法环境（Lexical Environment）**：用于标识符解析，包括变量和作用域链。
- **外部环境引用（Outer Environment Reference）**：在全局上下文中为 `null`。

### 全局变量和函数声明

- 声明函数 `outer`，并将其存储在全局变量环境中。
- 声明变量 `innerFunc`，初始值为 `undefined`。

---

## 2. 执行 `var innerFunc = outer();`

### 2.1 调用 `outer()`，创建 `outer` 函数的执行上下文

- 创建 `outer` 函数的**执行上下文**，并将其压入执行栈顶部。
- `outer` 的执行上下文包含：
  - **变量环境**：包含函数内声明的变量 `b`。
  - **词法环境**：用于标识符解析。
  - **外部环境引用**：指向全局执行上下文的变量环境。

### 2.2 执行 `outer` 函数内部代码

- 声明并初始化变量 `b`，赋值为 `2`。
- 定义并返回内部函数 `inner`。

### 2.3 `outer` 执行完毕，执行上下文出栈

- `outer` 函数返回了内部函数 `inner` 的引用。
- `outer` 的执行上下文从执行栈中弹出。

---

## 3. 闭包的形成

- 虽然 `outer` 函数的执行上下文已出栈，但由于返回的 `inner` 函数引用了 `outer` 内的变量 `b`，形成了**闭包**。
- 闭包使得 `inner` 函数持有对其**词法环境**的引用，即使 `outer` 函数已执行完毕。

---

## 4. 执行 `innerFunc();`

### 4.1 调用 `innerFunc()`，创建 `inner` 函数的执行上下文

- 创建 `inner` 函数的**执行上下文**，并将其压入执行栈顶部。
- `inner` 的执行上下文包含：
  - **变量环境**：函数内的变量和函数声明（本例中无）。
  - **词法环境**：用于标识符解析。
  - **外部环境引用**：指向 `outer` 函数的变量环境。

### 4.2 执行 `inner` 函数内部代码

- 执行 `console.log(b);`。
- **标识符解析过程**：
  - 在 `inner` 的变量环境中查找 `b`，未找到。
  - 沿着作用域链到 `outer` 的变量环境中查找，找到 `b = 2`。
- 输出结果 `2`。

### 4.3 `inner` 执行完毕，执行上下文出栈

- `inner` 函数的执行上下文从执行栈中弹出。

---

## 5. 作用域链和执行栈的总结

### 5.1 作用域链

- **作用域链**是由多个执行上下文的变量环境组成，用于标识符的解析。
- 在函数定义时，作用域链就已经确定，函数可以访问其定义时的词法环境中的变量。

### 5.2 执行栈

- **执行栈**用于管理函数调用的执行顺序。
- 每当函数被调用时，都会创建新的执行上下文并压入栈顶。
- 函数执行完毕后，执行上下文从栈顶弹出。

---

## 6. 总体流程图

1. **全局执行上下文**创建，`outer` 函数和 `innerFunc` 变量声明。
2. 调用 `outer()`：
   - 创建 `outer` 执行上下文并压入执行栈。
   - 声明变量 `b`，定义并返回 `inner` 函数。
   - `outer` 执行上下文出栈。
3. **闭包形成**：`inner` 函数持有对 `outer` 词法环境的引用。
4. 调用 `innerFunc()`：
   - 创建 `inner` 执行上下文并压入执行栈。
   - 执行 `console.log(b);`，通过作用域链查找变量 `b`，输出 `2`。
   - `inner` 执行上下文出栈。

---

## 7. 结论

- **闭包**使得内部函数可以访问其外部函数的变量，即使外部函数已执行完毕。
- **作用域链**确保了标识符解析的正确性，沿着定义时的词法环境查找变量。
- **执行栈**管理函数调用的执行顺序，控制执行上下文的创建和销毁。

---

通过以上分析，我们详细了解了这段代码在执行过程中涉及的底层机制，包括作用域链、执行栈和执行上下文的变化。